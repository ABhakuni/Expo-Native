{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.ActionsTest = exports.ActionMap = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _Util = require(\"./Util\");\n\nvar _Scene = _interopRequireDefault(require(\"./Scene\"));\n\nvar ActionConst = _interopRequireWildcard(require(\"./ActionConst\"));\n\nvar _ActionMap;\n\nfunction _createForOfIteratorHelperLoose(o) { var i = 0; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } i = o[Symbol.iterator](); return i.next.bind(i); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar ActionMap = (_ActionMap = {\n  jump: ActionConst.JUMP,\n  push: ActionConst.PUSH,\n  replace: ActionConst.REPLACE,\n  back: ActionConst.BACK,\n  BackAction: ActionConst.BACK_ACTION,\n  popAndReplace: ActionConst.POP_AND_REPLACE,\n  popTo: ActionConst.POP_TO,\n  refresh: ActionConst.REFRESH,\n  reset: ActionConst.RESET,\n  focus: ActionConst.FOCUS,\n  pushOrPop: ActionConst.PUSH_OR_POP,\n  androidBack: ActionConst.ANDROID_BACK\n}, (0, _defineProperty2.default)(_ActionMap, ActionConst.JUMP, ActionConst.JUMP), (0, _defineProperty2.default)(_ActionMap, ActionConst.PUSH, ActionConst.PUSH), (0, _defineProperty2.default)(_ActionMap, ActionConst.REPLACE, ActionConst.REPLACE), (0, _defineProperty2.default)(_ActionMap, ActionConst.BACK, ActionConst.BACK), (0, _defineProperty2.default)(_ActionMap, ActionConst.BACK_ACTION, ActionConst.BACK_ACTION), (0, _defineProperty2.default)(_ActionMap, ActionConst.POP_AND_REPLACE, ActionConst.POP_AND_REPLACE), (0, _defineProperty2.default)(_ActionMap, ActionConst.POP_TO, ActionConst.POP_TO), (0, _defineProperty2.default)(_ActionMap, ActionConst.REFRESH, ActionConst.REFRESH), (0, _defineProperty2.default)(_ActionMap, ActionConst.RESET, ActionConst.RESET), (0, _defineProperty2.default)(_ActionMap, ActionConst.FOCUS, ActionConst.FOCUS), (0, _defineProperty2.default)(_ActionMap, ActionConst.PUSH_OR_POP, ActionConst.PUSH_OR_POP), (0, _defineProperty2.default)(_ActionMap, ActionConst.ANDROID_BACK, ActionConst.ANDROID_BACK), _ActionMap);\nexports.ActionMap = ActionMap;\n\nfunction filterParam(data) {\n  if (data.toString() !== '[object Object]') {\n    return {\n      data: data\n    };\n  }\n\n  var proto = (data || {}).constructor.name;\n\n  if (!data || proto !== 'Object') {\n    return {};\n  }\n\n  return data;\n}\n\nvar reservedKeys = ['create', 'callback', 'iterate', 'current'].concat((0, _toConsumableArray2.default)(Object.keys(ActionMap)));\n\nfunction getInheritProps(props) {\n  var key = props.key,\n      style = props.style,\n      type = props.type,\n      component = props.component,\n      tabs = props.tabs,\n      sceneKey = props.sceneKey,\n      parent = props.parent,\n      children = props.children,\n      parentProps = (0, _objectWithoutProperties2.default)(props, [\"key\", \"style\", \"type\", \"component\", \"tabs\", \"sceneKey\", \"parent\", \"children\"]);\n  return parentProps.passProps ? parentProps : {};\n}\n\nvar Actions = function () {\n  function Actions() {\n    (0, _classCallCheck2.default)(this, Actions);\n    this.callback = null;\n    this.create = this.create.bind(this);\n    this.iterate = this.iterate.bind(this);\n    this.pop = this.pop.bind(this);\n    this.refresh = this.refresh.bind(this);\n    this.focus = this.focus.bind(this);\n  }\n\n  (0, _createClass2.default)(Actions, [{\n    key: \"iterate\",\n    value: function iterate(root) {\n      var _this = this;\n\n      var parentProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var refsParam = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var wrapBy = arguments.length > 3 ? arguments[3] : undefined;\n      var refs = refsParam;\n      (0, _Util.assert)(root.props, 'props should be defined for stack');\n      var key = root.key;\n      (0, _Util.assert)(key, 'unique key should be defined ');\n      (0, _Util.assert)(reservedKeys.indexOf(key) === -1, \"'\" + key + \"' is not allowed as key name. Reserved keys: [\" + reservedKeys.join(', ') + \"]\");\n      var _root$props = root.props,\n          children = _root$props.children,\n          component = _root$props.component,\n          staticProps = (0, _objectWithoutProperties2.default)(_root$props, [\"children\", \"component\"]);\n      var type = root.props.type || (parentProps.tabs ? ActionConst.JUMP : ActionConst.PUSH);\n\n      if (type === 'switch') {\n        type = ActionConst.JUMP;\n      }\n\n      var inheritProps = getInheritProps(parentProps);\n      var componentProps = component ? {\n        component: wrapBy(component)\n      } : {};\n\n      if (wrapBy) {\n        Object.keys(staticProps).forEach(function (prop) {\n          var componentClass = staticProps[prop];\n\n          if (componentClass && componentClass.prototype && componentClass.prototype.render) {\n            componentProps[prop] = wrapBy(componentClass);\n            delete staticProps[prop];\n          }\n        });\n      }\n\n      var res = _objectSpread({\n        key: key,\n        name: key,\n        sceneKey: key,\n        parent: parentProps.key,\n        type: type\n      }, inheritProps, {}, staticProps, {}, componentProps);\n\n      var list = children || [];\n      var normalized = [];\n\n      if (!(list instanceof Array)) {\n        list = [list];\n      }\n\n      list.forEach(function (item) {\n        if (item) {\n          if (item instanceof Array) {\n            item.forEach(function (it) {\n              normalized.push(it);\n            });\n          } else {\n            normalized.push(item);\n          }\n        }\n      });\n      list = normalized;\n\n      var condition = function condition(el) {\n        return !el.props.component && !el.props.children && !el.props.onPress && (!el.props.type || ActionMap[el.props.type] === ActionConst.REFRESH);\n      };\n\n      var baseKey = root.key;\n      var subStateParent = parentProps.key;\n      var subStates = list.filter(condition);\n      list = list.filter(function (el) {\n        return !condition(el);\n      });\n\n      if (list.length) {\n        res.children = list.map(function (c) {\n          return _this.iterate(c, res, refs, wrapBy).key;\n        });\n      } else {\n        if (!staticProps.onPress) {\n          (0, _Util.assert)(component, \"component property is not set for key=\" + key);\n        }\n\n        if (parentProps.tabs) {\n          var innerKey = res.key + \"_\";\n          baseKey = innerKey;\n          subStateParent = res.key;\n\n          var inner = _objectSpread({}, res, {\n            name: key,\n            key: innerKey,\n            sceneKey: innerKey,\n            type: ActionConst.PUSH,\n            parent: res.key\n          });\n\n          refs[innerKey] = inner;\n          res.children = [innerKey];\n          delete res.component;\n        }\n\n        res.index = 0;\n      }\n\n      var _loop = function _loop(el) {\n        refs[el.key] = _objectSpread({\n          key: el.key,\n          name: el.key\n        }, el.props, {\n          type: ActionConst.REFRESH,\n          base: baseKey,\n          parent: subStateParent\n        });\n\n        if (_this[el.key]) {\n          console.log(\"Key \" + el.key + \" is already defined!\");\n        }\n\n        _this[el.key] = function () {\n          var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          (0, _Util.assert)(_this.callback, 'Actions.callback is not defined!');\n\n          _this.callback(_objectSpread({\n            key: el.key,\n            type: ActionConst.REFRESH\n          }, filterParam(props)));\n        };\n      };\n\n      for (var _iterator = _createForOfIteratorHelperLoose(subStates), _step; !(_step = _iterator()).done;) {\n        var el = _step.value;\n\n        _loop(el);\n      }\n\n      if (this[key]) {\n        console.log(\"Key \" + key + \" is already defined!\");\n      }\n\n      this[key] = function () {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        (0, _Util.assert)(_this.callback, 'Actions.callback is not defined!');\n\n        _this.callback(_objectSpread({\n          key: key,\n          type: type\n        }, filterParam(props)));\n      };\n\n      refs[res.key] = res;\n      return res;\n    }\n  }, {\n    key: \"popTo\",\n    value: function popTo() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.callback(_objectSpread({}, filterParam(props), {\n        type: ActionConst.POP_TO\n      }));\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.callback(_objectSpread({}, filterParam(props), {\n        type: ActionConst.BACK_ACTION\n      }));\n    }\n  }, {\n    key: \"jump\",\n    value: function jump() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.callback(_objectSpread({}, filterParam(props), {\n        type: ActionConst.JUMP\n      }));\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.callback(_objectSpread({}, filterParam(props), {\n        type: ActionConst.REFRESH\n      }));\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.callback(_objectSpread({}, filterParam(props), {\n        type: ActionConst.FOCUS\n      }));\n    }\n  }, {\n    key: \"androidBack\",\n    value: function androidBack() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.callback(_objectSpread({}, filterParam(props), {\n        type: ActionConst.ANDROID_BACK\n      }));\n    }\n  }, {\n    key: \"create\",\n    value: function create(scene) {\n      var wrapBy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (x) {\n        return x;\n      };\n      (0, _Util.assert)(scene, 'root scene should be defined');\n      var refs = {};\n      this.iterate(scene, {}, refs, wrapBy);\n      return refs;\n    }\n  }]);\n  return Actions;\n}();\n\nexports.ActionsTest = Actions;\n\nvar _default = new Actions();\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/apple/Documents/janitri/sampleapp/node_modules/react-native-router-flux/src/Actions.js"],"names":["ActionMap","jump","ActionConst","JUMP","push","PUSH","replace","REPLACE","back","BACK","BackAction","BACK_ACTION","popAndReplace","POP_AND_REPLACE","popTo","POP_TO","refresh","REFRESH","reset","RESET","focus","FOCUS","pushOrPop","PUSH_OR_POP","androidBack","ANDROID_BACK","filterParam","data","toString","proto","constructor","name","reservedKeys","Object","keys","getInheritProps","props","key","style","type","component","tabs","sceneKey","parent","children","parentProps","passProps","Actions","callback","create","bind","iterate","pop","root","refsParam","wrapBy","refs","indexOf","join","staticProps","inheritProps","componentProps","forEach","prop","componentClass","prototype","render","res","list","normalized","Array","item","it","condition","el","onPress","baseKey","subStateParent","subStates","filter","length","map","c","innerKey","inner","index","base","console","log","scene","x"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Pavel Aksonov\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { assert } from './Util';\nimport Scene from './Scene';\nimport * as ActionConst from './ActionConst';\n\nexport const ActionMap = {\n  jump: ActionConst.JUMP,\n  push: ActionConst.PUSH,\n  replace: ActionConst.REPLACE,\n  back: ActionConst.BACK,\n  BackAction: ActionConst.BACK_ACTION,\n  popAndReplace: ActionConst.POP_AND_REPLACE,\n  popTo: ActionConst.POP_TO,\n  refresh: ActionConst.REFRESH,\n  reset: ActionConst.RESET,\n  focus: ActionConst.FOCUS,\n  pushOrPop: ActionConst.PUSH_OR_POP,\n  androidBack: ActionConst.ANDROID_BACK,\n  [ActionConst.JUMP]: ActionConst.JUMP,\n  [ActionConst.PUSH]: ActionConst.PUSH,\n  [ActionConst.REPLACE]: ActionConst.REPLACE,\n  [ActionConst.BACK]: ActionConst.BACK,\n  [ActionConst.BACK_ACTION]: ActionConst.BACK_ACTION,\n  [ActionConst.POP_AND_REPLACE]: ActionConst.POP_AND_REPLACE,\n  [ActionConst.POP_TO]: ActionConst.POP_TO,\n  [ActionConst.REFRESH]: ActionConst.REFRESH,\n  [ActionConst.RESET]: ActionConst.RESET,\n  [ActionConst.FOCUS]: ActionConst.FOCUS,\n  [ActionConst.PUSH_OR_POP]: ActionConst.PUSH_OR_POP,\n  [ActionConst.ANDROID_BACK]: ActionConst.ANDROID_BACK,\n};\n\nfunction filterParam(data) {\n  if (data.toString() !== '[object Object]') {\n    return { data };\n  }\n  const proto = (data || {}).constructor.name;\n  // avoid passing React Native parameters\n  if (!data || (proto !== 'Object')) {\n    return {};\n  }\n  return data;\n}\n\nconst reservedKeys = [\n  'create',\n  'callback',\n  'iterate',\n  'current',\n  ...Object.keys(ActionMap),\n];\n\nfunction getInheritProps(props) {\n  // eslint-disable-next-line no-unused-vars\n  const { key, style, type, component, tabs, sceneKey, parent, children, ...parentProps } = props;\n  return parentProps.passProps ? parentProps : {};\n}\n\nclass Actions {\n  constructor() {\n    this.callback = null;\n    this.create = this.create.bind(this);\n    this.iterate = this.iterate.bind(this);\n    this.pop = this.pop.bind(this);\n    this.refresh = this.refresh.bind(this);\n    this.focus = this.focus.bind(this);\n  }\n\n  iterate(root: Scene, parentProps = {}, refsParam = {}, wrapBy) {\n    const refs = refsParam;\n    assert(root.props, 'props should be defined for stack');\n    const key = root.key;\n    assert(key, 'unique key should be defined ');\n    assert(\n      reservedKeys.indexOf(key) === -1,\n      `'${key}' is not allowed as key name. Reserved keys: [${reservedKeys.join(', ')}]`,\n    );\n    const { children, component, ...staticProps } = root.props;\n    let type = root.props.type || (parentProps.tabs ? ActionConst.JUMP : ActionConst.PUSH);\n    if (type === 'switch') {\n      type = ActionConst.JUMP;\n    }\n    const inheritProps = getInheritProps(parentProps);\n    const componentProps = component ? { component: wrapBy(component) } : {};\n    // wrap other components\n    if (wrapBy) {\n      Object.keys(staticProps).forEach((prop) => {\n        const componentClass = staticProps[prop];\n        if (componentClass && componentClass.prototype && componentClass.prototype.render) {\n          componentProps[prop] = wrapBy(componentClass);\n          delete staticProps[prop];\n        }\n      });\n    }\n    const res = {\n      key,\n      name: key,\n      sceneKey: key,\n      parent: parentProps.key,\n      type,\n      ...inheritProps,\n      ...staticProps,\n      ...componentProps,\n    };\n    let list = children || [];\n    const normalized = [];\n    if (!(list instanceof Array)) {\n      list = [list];\n    }\n    list.forEach((item) => {\n      if (item) {\n        if (item instanceof Array) {\n          item.forEach((it) => {\n            normalized.push(it);\n          });\n        } else {\n          normalized.push(item);\n        }\n      }\n    });\n    list = normalized; // normalize the list of scenes\n\n    const condition = el => (!el.props.component && !el.props.children && !el.props.onPress &&\n    (!el.props.type || ActionMap[el.props.type] === ActionConst.REFRESH));\n    // determine sub-states\n    let baseKey = root.key;\n    let subStateParent = parentProps.key;\n    const subStates = list.filter(condition);\n    list = list.filter(el => !condition(el));\n    if (list.length) {\n      res.children = list.map(c => this.iterate(c, res, refs, wrapBy).key);\n    } else {\n      if (!staticProps.onPress) {\n        assert(component, `component property is not set for key=${key}`);\n      }\n      // wrap scene if parent is \"tabs\"\n      if (parentProps.tabs) {\n        const innerKey = `${res.key}_`;\n        baseKey = innerKey;\n        subStateParent = res.key;\n        const inner = { ...res,\n          name: key,\n          key: innerKey,\n          sceneKey: innerKey,\n          type: ActionConst.PUSH,\n          parent: res.key };\n        refs[innerKey] = inner;\n        res.children = [innerKey];\n        delete res.component;\n      }\n      res.index = 0;\n    }\n    // process substates\n    for (const el of subStates) {\n      refs[el.key] = { key: el.key,\n        name: el.key,\n        ...el.props,\n        type: ActionConst.REFRESH,\n        base: baseKey,\n        parent: subStateParent };\n      if (this[el.key]) {\n        console.log(`Key ${el.key} is already defined!`);\n      }\n      this[el.key] =\n        (props = {}) => {\n          assert(this.callback, 'Actions.callback is not defined!');\n          this.callback({ key: el.key, type: ActionConst.REFRESH, ...filterParam(props) });\n        };\n    }\n    if (this[key]) {\n      console.log(`Key ${key} is already defined!`);\n    }\n    this[key] =\n      (props = {}) => {\n        assert(this.callback, 'Actions.callback is not defined!');\n        this.callback({ key, type, ...filterParam(props) });\n      };\n    refs[res.key] = res;\n\n    return res;\n  }\n\n  popTo(props = {}) {\n    return this.callback({ ...filterParam(props), type: ActionConst.POP_TO });\n  }\n\n  pop(props = {}) {\n    return this.callback({ ...filterParam(props), type: ActionConst.BACK_ACTION });\n  }\n\n  jump(props = {}) {\n    return this.callback({ ...filterParam(props), type: ActionConst.JUMP });\n  }\n\n  refresh(props = {}) {\n    return this.callback({ ...filterParam(props), type: ActionConst.REFRESH });\n  }\n\n  focus(props = {}) {\n    return this.callback({ ...filterParam(props), type: ActionConst.FOCUS });\n  }\n\n  androidBack(props = {}) {\n    return this.callback({ ...filterParam(props), type: ActionConst.ANDROID_BACK });\n  }\n\n  create(scene:Scene, wrapBy = x => x) {\n    assert(scene, 'root scene should be defined');\n    const refs = {};\n    this.iterate(scene, {}, refs, wrapBy);\n    return refs;\n  }\n}\n\nexport { Actions as ActionsTest };\nexport default new Actions();\n"]},"metadata":{},"sourceType":"script"}