{"ast":null,"code":"'use strict';\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar SCENE_KEY_PREFIX = 'scene_';\n\nfunction compareKey(one, two) {\n  var delta = one.length - two.length;\n\n  if (delta > 0) {\n    return 1;\n  }\n\n  if (delta < 0) {\n    return -1;\n  }\n\n  return one > two ? 1 : -1;\n}\n\nfunction compareScenes(one, two) {\n  if (one.index > two.index) {\n    return 1;\n  }\n\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\nfunction areScenesShallowEqual(one, two) {\n  return one.key === two.key && one.index === two.index && one.isStale === two.isStale && one.navigationState === two.navigationState && one.navigationState.key === two.navigationState.key;\n}\n\nfunction NavigationScenesReducer(scenes, nextState, prevState) {\n  var prevScenes = new Map();\n  var freshScenes = new Map();\n  var staleScenes = new Map();\n  scenes.forEach(function (scene) {\n    var key = scene.key;\n\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n\n    prevScenes.set(key, scene);\n  });\n  var nextKeys = new Set();\n  nextState.children.forEach(function (navigationState, index) {\n    var key = SCENE_KEY_PREFIX + navigationState.key;\n    var scene = {\n      index: index,\n      isStale: false,\n      key: key,\n      navigationState: navigationState\n    };\n    invariant(!nextKeys.has(key), \"navigationState.children[\" + index + \"].key \\\"\" + key + \"\\\" conflicts with\" + 'another child!');\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      staleScenes.delete(key);\n    }\n\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    prevState.children.forEach(function (navigationState, index) {\n      var key = SCENE_KEY_PREFIX + navigationState.key;\n\n      if (freshScenes.has(key)) {\n        return;\n      }\n\n      staleScenes.set(key, {\n        index: index,\n        isStale: true,\n        key: key,\n        navigationState: navigationState\n      });\n    });\n  }\n\n  var nextScenes = [];\n\n  var mergeScene = function mergeScene(nextScene) {\n    var key = nextScene.key;\n    var prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n  return nextScenes.sort(compareScenes);\n}\n\nmodule.exports = NavigationScenesReducer;","map":{"version":3,"sources":["/Users/apple/Documents/janitri/sampleapp/node_modules/react-native-experimental-navigation/NavigationScenesReducer.js"],"names":["invariant","require","SCENE_KEY_PREFIX","compareKey","one","two","delta","length","compareScenes","index","key","areScenesShallowEqual","isStale","navigationState","NavigationScenesReducer","scenes","nextState","prevState","prevScenes","Map","freshScenes","staleScenes","forEach","scene","set","nextKeys","Set","children","has","add","delete","nextScenes","mergeScene","nextScene","prevScene","get","push","sort","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule NavigationScenesReducer\n * @flow\n */\n'use strict';\n\nconst invariant = require('fbjs/lib/invariant');\n\nimport type {\n  NavigationParentState,\n  NavigationScene,\n} from 'NavigationTypeDefinition';\n\nconst SCENE_KEY_PREFIX = 'scene_';\n\n/**\n * Helper function to compare route keys (e.g. \"9\", \"11\").\n */\nfunction compareKey(one: string, two: string): number {\n  var delta = one.length - two.length;\n  if (delta > 0) {\n    return 1;\n  }\n  if (delta < 0) {\n    return -1;\n  }\n  return one > two ? 1 : -1;\n}\n\n/**\n * Helper function to sort scenes based on their index and view key.\n */\nfunction compareScenes(\n  one: NavigationScene,\n  two: NavigationScene,\n): number {\n  if (one.index > two.index) {\n    return 1;\n  }\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(\n    one.key,\n    two.key,\n  );\n}\n\nfunction areScenesShallowEqual(\n  one: NavigationScene,\n  two: NavigationScene,\n): boolean {\n  return (\n    one.key === two.key &&\n    one.index === two.index &&\n    one.isStale === two.isStale &&\n    one.navigationState === two.navigationState &&\n    one.navigationState.key === two.navigationState.key\n  );\n}\n\nfunction NavigationScenesReducer(\n  scenes: Array<NavigationScene>,\n  nextState: NavigationParentState,\n  prevState: ?NavigationParentState,\n): Array<NavigationScene> {\n\n  const prevScenes = new Map();\n  const freshScenes = new Map();\n  const staleScenes = new Map();\n\n  // Populate stale scenes from previous scenes marked as stale.\n  scenes.forEach(scene => {\n    const {key} = scene;\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n    prevScenes.set(key, scene);\n  });\n\n  const nextKeys = new Set();\n  nextState.children.forEach((navigationState, index) => {\n    const key = SCENE_KEY_PREFIX + navigationState.key;\n    const scene = {\n      index,\n      isStale: false,\n      key,\n      navigationState,\n    };\n    invariant(\n      !nextKeys.has(key),\n      `navigationState.children[${index}].key \"${key}\" conflicts with` +\n        'another child!'\n    );\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      // A previously `stale` scene is now part of the nextState, so we\n      // revive it by removing it from the stale scene map.\n      staleScenes.delete(key);\n    }\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    // Look at the previous children and classify any removed scenes as `stale`.\n    prevState.children.forEach((navigationState, index) => {\n      const key = SCENE_KEY_PREFIX + navigationState.key;\n      if (freshScenes.has(key)) {\n        return;\n      }\n      staleScenes.set(key, {\n        index,\n        isStale: true,\n        key,\n        navigationState,\n      });\n    });\n  }\n\n  const nextScenes = [];\n\n  const mergeScene = (nextScene => {\n    const {key} = nextScene;\n    const prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      // Reuse `prevScene` as `scene` so view can avoid unnecessary re-render.\n      // This assumes that the scene's navigation state is immutable.\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  });\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n\n  return nextScenes.sort(compareScenes);\n}\n\nmodule.exports = NavigationScenesReducer;\n"]},"metadata":{},"sourceType":"script"}