{"ast":null,"code":"var _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findElement = findElement;\nexports.getCurrent = getCurrent;\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _lodash = _interopRequireDefault(require(\"lodash.isequal\"));\n\nvar ActionConst = _interopRequireWildcard(require(\"./ActionConst\"));\n\nvar _Actions = require(\"./Actions\");\n\nvar _Util = require(\"./Util\");\n\nvar _State = require(\"./State\");\n\nfunction _createForOfIteratorHelperLoose(o) { var i = 0; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } i = o[Symbol.iterator](); return i.next.bind(i); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction checkPropertiesEqual(action, lastAction) {\n  for (var _i = 0, _Object$keys = Object.keys(action); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n\n    if (['key', 'type', 'parent'].indexOf(key) === -1) {\n      if (!(0, _lodash.default)(action[key], lastAction[key]) && typeof action[key] !== 'function' && typeof lastAction[key] !== 'function') {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction resetHistoryStack(state) {\n  var newState = state;\n\n  if (newState.children) {\n    newState.index = 0;\n    var i;\n\n    for (i = 0; i < newState.children.length; i += 1) {\n      var el = newState.children[i];\n\n      if (el.initial) {\n        newState.index = i;\n\n        if (!newState.tabs) {\n          newState.children = [resetHistoryStack(el)];\n        } else {\n          newState.children[i] = resetHistoryStack(el);\n        }\n      } else {\n        newState.children[i] = resetHistoryStack(el);\n      }\n    }\n  }\n\n  return newState;\n}\n\nfunction refreshTopChild(children, refresh) {\n  if (refresh) {\n    var topChild = children[children.length - 1];\n    return [].concat((0, _toConsumableArray2.default)(children.slice(0, -1)), [_objectSpread({}, topChild, {}, refresh)]);\n  }\n\n  return children;\n}\n\nfunction inject(state, action, props, scenes) {\n  var condition = _Actions.ActionMap[action.type] === ActionConst.REFRESH ? state.key === props.key || state.sceneKey === action.key : state.sceneKey === props.parent;\n\n  if (!condition) {\n    if (state.children) {\n      var res = state.children.map(function (el) {\n        return inject(el, action, props, scenes);\n      });\n      var changed = false;\n      var changedIndex = -1;\n\n      for (var i = 0; i < res.length; i += 1) {\n        if (res[i] !== state.children[i]) {\n          changed = true;\n          changedIndex = i;\n          break;\n        }\n      }\n\n      return changed ? _objectSpread({}, state, {\n        children: res,\n        index: changedIndex\n      }) : state;\n    }\n\n    return state;\n  }\n\n  var ind;\n\n  switch (_Actions.ActionMap[action.type]) {\n    case ActionConst.POP_TO:\n      {\n        var targetIndex = action.targetIndex;\n        return _objectSpread({}, state, {\n          index: targetIndex,\n          children: refreshTopChild(state.children.slice(0, targetIndex + 1), action.refresh)\n        });\n      }\n\n    case ActionConst.BACK:\n    case ActionConst.BACK_ACTION:\n      {\n        (0, _Util.assert)(!state.tabs, 'pop() operation cannot be run on tab bar (tabs=true)');\n\n        if (state.index === 0) {\n          return state;\n        }\n\n        var popNum = 1;\n\n        if (action.popNum) {\n          (0, _Util.assert)(typeof action.popNum === 'number', 'The data is the number of scenes you want to pop, it must be Number');\n          popNum = action.popNum;\n          (0, _Util.assert)(popNum % 1 === 0, 'The data is the number of scenes you want to pop, it must be integer.');\n          (0, _Util.assert)(popNum > 1, 'The data is the number of scenes you want to pop, it must be bigger than 1.');\n          (0, _Util.assert)(popNum <= state.index, 'The data is the number of scenes you want to pop, ' + \"it must be smaller than scenes stack's length.\");\n        }\n\n        return _objectSpread({}, state, {\n          index: state.index - popNum,\n          from: state.children[state.children.length - popNum],\n          children: refreshTopChild(state.children.slice(0, -1 * popNum), action.refresh)\n        });\n      }\n\n    case ActionConst.ANDROID_BACK:\n      {\n        if (_reactNative.Platform.OS === 'android') {\n          (0, _Util.assert)(state.index > 0, 'You are already in the root scene.');\n        }\n\n        return _objectSpread({}, state, {\n          index: state.index - 1,\n          from: state.children[state.children.length - 1],\n          children: refreshTopChild(state.children.slice(0, -1), action.refresh)\n        });\n      }\n\n    case ActionConst.POP_AND_REPLACE:\n      {\n        (0, _Util.assert)(!state.tabs, 'pop() operation cannot be run on tab bar (tabs=true)');\n        (0, _Util.assert)(state.index > 0, 'You are already in the root scene.');\n        var _popNum = 1;\n\n        if (action.popNum) {\n          (0, _Util.assert)(typeof action.popNum === 'number', 'The data is the number of scenes you want to pop, it must be Number');\n          _popNum = action.popNum;\n          (0, _Util.assert)(_popNum % 1 === 0, 'The data is the number of scenes you want to pop, it must be integer.');\n          (0, _Util.assert)(_popNum > 1, 'The data is the number of scenes you want to pop, it must be bigger than 1.');\n          (0, _Util.assert)(_popNum <= state.index, 'The data is the number of scenes you want to pop, ' + \"it must be smaller than scenes stack's length.\");\n        }\n\n        state = _objectSpread({}, state, {\n          index: state.index - _popNum,\n          from: state.children[state.children.length - _popNum],\n          children: state.children.slice(0, -1 * _popNum)\n        });\n\n        if (state.children[state.index].sceneKey === action.key) {\n          return state;\n        }\n\n        var newAction = _objectSpread({\n          duration: 0\n        }, action);\n\n        delete newAction.popNum;\n\n        var newProps = _objectSpread({}, props);\n\n        delete newProps.popNum;\n        state.children[state.children.length - 1] = (0, _State.getInitialState)(newProps, scenes, state.index, newAction);\n        return _objectSpread({}, state, {\n          children: state.children\n        });\n      }\n\n    case ActionConst.REFRESH:\n      return props.base ? _objectSpread({\n        navBar: state.navBar\n      }, scenes.rootProps, {}, props, {\n        key: state.key,\n        from: null\n      }) : _objectSpread({}, state, {}, props, {\n        key: state.key,\n        from: null\n      });\n\n    case ActionConst.PUSH_OR_POP:\n      ind = state.children.findIndex(function (el) {\n        return el.sceneKey === action.key;\n      });\n\n      if (ind !== -1) {\n        return _objectSpread({}, state, {\n          index: ind,\n          from: state.children[state.index],\n          children: refreshTopChild(state.children.slice(0, ind + 1), action.refresh)\n        });\n      }\n\n      return _objectSpread({}, state, {\n        index: state.index + 1,\n        from: null,\n        children: [].concat((0, _toConsumableArray2.default)(state.children), [(0, _State.getInitialState)(props, scenes, state.index + 1, action)])\n      });\n\n    case ActionConst.PUSH:\n      if (state.children[state.index].sceneKey === action.key && !props.clone && checkPropertiesEqual(action, state.children[state.index])) {\n        return state;\n      }\n\n      return _objectSpread({}, state, {\n        index: state.index + 1,\n        from: null,\n        children: [].concat((0, _toConsumableArray2.default)(state.children), [(0, _State.getInitialState)(props, scenes, state.index + 1, action)])\n      });\n\n    case ActionConst.JUMP:\n      {\n        (0, _Util.assert)(state.tabs, \"Parent=\" + state.key + \" is not tab bar, jump action is not valid\");\n        ind = -1;\n        state.children.forEach(function (c, i) {\n          if (c.sceneKey === action.key) {\n            ind = i;\n          }\n        });\n        (0, _Util.assert)(ind !== -1, \"Cannot find route with key=\" + action.key + \" for parent=\" + state.key);\n        var activeChild = state.children[state.index];\n        var incomingChild = state.children[ind];\n        var incomingChildHadTabs = incomingChild.tabs;\n        var incomingChildWasActive = incomingChild.children.length > 1;\n        var activeChildIsIncomingChild = activeChild.sceneKey === action.key;\n\n        if (incomingChildHadTabs || !incomingChildWasActive || activeChildIsIncomingChild) {\n          state.children[ind] = (0, _State.getInitialState)(_objectSpread({}, props), scenes, state.index, _objectSpread({}, action, {\n            parentIndex: state.children[ind].parentIndex\n          }));\n        }\n\n        if (action.unmountScenes) {\n          var rState = resetHistoryStack(state);\n          return _objectSpread({}, rState, {\n            index: ind\n          });\n        }\n\n        return _objectSpread({}, state, {\n          index: ind\n        });\n      }\n\n    case ActionConst.REPLACE:\n      if (state.children[state.index].sceneKey === action.key) {\n        return state;\n      }\n\n      state.children[state.children.length - 1] = (0, _State.getInitialState)(props, scenes, state.index, action);\n      return _objectSpread({}, state, {\n        children: state.children\n      });\n\n    case ActionConst.RESET:\n      if (state.children[state.index].sceneKey === action.key) {\n        return state;\n      }\n\n      state.children = state.children.splice(0, 1);\n      state.children[0] = (0, _State.getInitialState)(props, scenes, 0, action);\n      return _objectSpread({}, state, {\n        index: 0,\n        from: null,\n        children: state.children\n      });\n\n    default:\n      return state;\n  }\n}\n\nfunction findElement(state, key, type) {\n  if (_Actions.ActionMap[type] === ActionConst.REFRESH && state.key === key || state.sceneKey === key) {\n    return state;\n  }\n\n  if (state.children) {\n    for (var _iterator = _createForOfIteratorHelperLoose(state.children), _step; !(_step = _iterator()).done;) {\n      var child = _step.value;\n      var current = findElement(child, key, type);\n      if (current) return current;\n    }\n  }\n\n  return null;\n}\n\nfunction getCurrent(state) {\n  if (!state.children) {\n    return state;\n  }\n\n  return getCurrent(state.children[state.index]);\n}\n\nfunction update(state, action) {\n  var props = _objectSpread({}, state.scenes[action.key], {}, action);\n\n  (0, _Util.assert)(props.parent, \"No parent is defined for route=\" + action.key);\n  return inject(state, action, props, state.scenes);\n}\n\nfunction reducer(_ref) {\n  var initialState = _ref.initialState,\n      scenes = _ref.scenes;\n  (0, _Util.assert)(initialState, 'initialState should not be null');\n  (0, _Util.assert)(initialState.key, 'initialState.key should not be null');\n  (0, _Util.assert)(scenes, 'scenes should not be null');\n  return function (stateParam, actionParam) {\n    var state = stateParam;\n    var action = actionParam;\n    state = state || _objectSpread({}, initialState, {\n      scenes: scenes\n    });\n    (0, _Util.assert)(action, 'action should be defined');\n    (0, _Util.assert)(action.type, 'action type should be defined');\n    (0, _Util.assert)(state.scenes, 'state.scenes is missed');\n\n    if (action.key) {\n      if (_Actions.ActionMap[action.type] === ActionConst.REFRESH) {\n        var key = action.key;\n        var child = findElement(state, key, action.type) || state.scenes[key];\n        var sceneKey = child.sceneKey;\n\n        if (child.base) {\n          child = _objectSpread({}, state.scenes[child.base], {}, child);\n          (0, _Util.assert)(state.scenes[child.base], \"No scene exists for base=\" + child.base);\n          key = state.scenes[child.base].key;\n          sceneKey = state.scenes[child.base].sceneKey;\n        }\n\n        (0, _Util.assert)(child, \"missed child data for key=\" + key);\n        var evaluated = {};\n        Object.keys(action).forEach(function (el) {\n          if (typeof action[el] === 'function' && typeof child[el] !== 'undefined' && typeof child[el] !== typeof action[el]) {\n            evaluated[el] = action[el](child[el], child);\n          }\n        });\n        action = _objectSpread({}, child, {}, action, {}, evaluated, {\n          sceneKey: sceneKey,\n          key: key\n        });\n      } else {\n        var scene = state.scenes[action.key];\n        (0, _Util.assert)(scene, \"missed route data for key=\" + action.key);\n\n        if (scene.clone) {\n          action.parent = getCurrent(state).parent;\n        }\n      }\n    } else {\n      if (_Actions.ActionMap[action.type] === ActionConst.BACK_ACTION || _Actions.ActionMap[action.type] === ActionConst.BACK || _Actions.ActionMap[action.type] === ActionConst.ANDROID_BACK || _Actions.ActionMap[action.type] === ActionConst.POP_AND_REPLACE || _Actions.ActionMap[action.type] === ActionConst.REFRESH || _Actions.ActionMap[action.type] === ActionConst.POP_TO) {\n        if (!action.key && !action.parent) {\n          action = _objectSpread({}, getCurrent(state), {}, action);\n        }\n      }\n\n      if (_Actions.ActionMap[action.type] === ActionConst.POP_TO) {\n        var target = action.data || action.scene;\n        (0, _Util.assert)(target, 'PopTo() must be called with a single argument: ' + 'either the scene name (string) or an object with within the scene property ' + 'carrying the target scene to pop to');\n        var targetEl = findElement(state, target, action.type);\n        (0, _Util.assert)(targetEl, \"Cannot find element name named \" + target + \" within current state\");\n        var parent = targetEl.sceneKey;\n        var targetIndex = 0;\n\n        if (!targetEl.children) {\n          var targetParent = findElement(state, targetEl.parent, action.type);\n          (0, _Util.assert)(targetParent, \"Cannot find parent for target \" + target);\n          parent = targetParent.sceneKey;\n          targetIndex = targetParent.children.indexOf(targetEl);\n          (0, _Util.assert)(targetIndex > -1, target + \" does not belong to \" + targetParent.sceneKey);\n        }\n\n        action.parent = parent;\n        action.targetIndex = targetIndex;\n      }\n\n      if (_Actions.ActionMap[action.type] === ActionConst.BACK_ACTION || _Actions.ActionMap[action.type] === ActionConst.BACK || _Actions.ActionMap[action.type] === ActionConst.ANDROID_BACK || _Actions.ActionMap[action.type] === ActionConst.POP_AND_REPLACE) {\n        var _parent = action.parent || state.scenes[action.key].parent;\n\n        var el = findElement(state, _parent, action.type);\n\n        while (el.parent && (el.children.length <= 1 || el.tabs)) {\n          el = findElement(state, el.parent, action.type);\n          (0, _Util.assert)(el, \"Cannot find element for parent=\" + el.parent + \" within current state\");\n        }\n\n        action.parent = el.sceneKey;\n      }\n    }\n\n    switch (_Actions.ActionMap[action.type]) {\n      case ActionConst.BACK:\n      case ActionConst.BACK_ACTION:\n      case ActionConst.POP_AND_REPLACE:\n      case ActionConst.POP_TO:\n      case ActionConst.REFRESH:\n      case ActionConst.PUSH:\n      case ActionConst.PUSH_OR_POP:\n      case ActionConst.JUMP:\n      case ActionConst.REPLACE:\n      case ActionConst.RESET:\n      case ActionConst.ANDROID_BACK:\n        return update(state, action);\n\n      default:\n        return state;\n    }\n  };\n}\n\nvar _default = reducer;\nexports.default = _default;","map":{"version":3,"sources":["/Users/apple/Documents/janitri/sampleapp/node_modules/react-native-router-flux/src/Reducer.js"],"names":["checkPropertiesEqual","action","lastAction","Object","keys","key","indexOf","resetHistoryStack","state","newState","children","index","i","length","el","initial","tabs","refreshTopChild","refresh","topChild","slice","inject","props","scenes","condition","ActionMap","type","ActionConst","REFRESH","sceneKey","parent","res","map","changed","changedIndex","ind","POP_TO","targetIndex","BACK","BACK_ACTION","popNum","from","ANDROID_BACK","Platform","OS","POP_AND_REPLACE","newAction","duration","newProps","base","navBar","rootProps","PUSH_OR_POP","findIndex","PUSH","clone","JUMP","forEach","c","activeChild","incomingChild","incomingChildHadTabs","incomingChildWasActive","activeChildIsIncomingChild","parentIndex","unmountScenes","rState","REPLACE","RESET","splice","findElement","child","current","getCurrent","update","reducer","initialState","stateParam","actionParam","evaluated","scene","target","data","targetEl","targetParent"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Pavel Aksonov\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/* eslint-disable no-param-reassign */\n\nimport { Platform } from 'react-native';\nimport isEqual from 'lodash.isequal';\nimport * as ActionConst from './ActionConst';\nimport { ActionMap } from './Actions';\nimport { assert } from './Util';\nimport { getInitialState } from './State';\n\nfunction checkPropertiesEqual(action, lastAction) {\n  for (const key of Object.keys(action)) {\n    if (['key', 'type', 'parent'].indexOf(key) === -1) {\n      if (!isEqual(action[key], lastAction[key]) && (typeof action[key] !== 'function') && (typeof lastAction[key] !== 'function')) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction resetHistoryStack(state) {\n  const newState = state;\n\n  if (newState.children) {\n    newState.index = 0;\n\n    let i;\n    for (i = 0; i < newState.children.length; i += 1) {\n      const el = newState.children[i];\n\n      if (el.initial) {\n        newState.index = i;\n\n        if (!newState.tabs) {\n          newState.children = [resetHistoryStack(el)];\n        } else {\n          newState.children[i] = resetHistoryStack(el);\n        }\n      } else {\n        newState.children[i] = resetHistoryStack(el);\n      }\n    }\n  }\n  return newState;\n}\n\nfunction refreshTopChild(children, refresh) {\n  if (refresh) {\n    const topChild = children[children.length - 1];\n    return [...children.slice(0, -1), { ...topChild, ...refresh }];\n  }\n  return children;\n}\n\nfunction inject(state, action, props, scenes) {\n  const condition = ActionMap[action.type] === ActionConst.REFRESH ? state.key === props.key ||\n    state.sceneKey === action.key : state.sceneKey === props.parent;\n  // console.log(\"INJECT:\", action.key, state.sceneKey, condition);\n  if (!condition) {\n    if (state.children) {\n      const res = state.children.map(el => inject(el, action, props, scenes));\n      let changed = false;\n      let changedIndex = -1;\n      for (let i = 0; i < res.length; i += 1) {\n        if (res[i] !== state.children[i]) {\n          changed = true;\n          changedIndex = i;\n          break;\n        }\n      }\n      return changed ? { ...state, children: res, index: changedIndex } : state;\n    }\n    return state;\n  }\n  let ind;\n\n  switch (ActionMap[action.type]) {\n    case ActionConst.POP_TO: {\n      const targetIndex = action.targetIndex;\n\n      return {\n        ...state,\n        index: targetIndex,\n        children: refreshTopChild(state.children.slice(0, (targetIndex + 1)), action.refresh),\n      };\n    }\n\n    case ActionConst.BACK:\n    case ActionConst.BACK_ACTION: {\n      assert(!state.tabs, 'pop() operation cannot be run on tab bar (tabs=true)');\n\n      if (state.index === 0) {\n        return state;\n      }\n\n      let popNum = 1;\n      if (action.popNum) {\n        assert(typeof (action.popNum) === 'number',\n          'The data is the number of scenes you want to pop, it must be Number');\n        popNum = action.popNum;\n        assert(popNum % 1 === 0,\n          'The data is the number of scenes you want to pop, it must be integer.');\n        assert(popNum > 1,\n          'The data is the number of scenes you want to pop, it must be bigger than 1.');\n        assert(popNum <= state.index,\n          'The data is the number of scenes you want to pop, ' +\n          \"it must be smaller than scenes stack's length.\");\n      }\n\n      return {\n        ...state,\n        index: state.index - popNum,\n        from: state.children[state.children.length - popNum],\n        children: refreshTopChild(state.children.slice(0, -1 * popNum), action.refresh),\n      };\n    }\n    case ActionConst.ANDROID_BACK: {\n      if (Platform.OS === 'android') {\n        assert(state.index > 0, 'You are already in the root scene.');\n      }\n\n      return {\n        ...state,\n        index: state.index - 1,\n        from: state.children[state.children.length - 1],\n        children: refreshTopChild(state.children.slice(0, -1), action.refresh),\n      };\n    }\n    // This action will pop the scene stack and then replace current scene in one go\n    case ActionConst.POP_AND_REPLACE: {\n      assert(!state.tabs, 'pop() operation cannot be run on tab bar (tabs=true)');\n      assert(state.index > 0, 'You are already in the root scene.');\n\n      let popNum = 1;\n      if (action.popNum) {\n        assert(typeof (action.popNum) === 'number',\n          'The data is the number of scenes you want to pop, it must be Number');\n        popNum = action.popNum;\n        assert(popNum % 1 === 0,\n          'The data is the number of scenes you want to pop, it must be integer.');\n        assert(popNum > 1,\n          'The data is the number of scenes you want to pop, it must be bigger than 1.');\n        assert(popNum <= state.index,\n          'The data is the number of scenes you want to pop, ' +\n          \"it must be smaller than scenes stack's length.\");\n      }\n\n      state = {\n        ...state,\n        index: state.index - popNum,\n        from: state.children[state.children.length - popNum],\n        children: state.children.slice(0, -1 * popNum),\n      };\n\n      if (state.children[state.index].sceneKey === action.key) {\n        return state;\n      }\n\n      const newAction = {\n        duration: 0,  // do not animate\n        ...action,\n      };\n      delete newAction.popNum;\n\n      const newProps = { ...props };\n      delete newProps.popNum;\n\n      state.children[state.children.length - 1] = getInitialState(\n        newProps,\n        scenes,\n        state.index,\n        newAction,\n      );\n\n      return { ...state, children: state.children };\n    }\n    case ActionConst.REFRESH:\n      return props.base ? {\n        navBar: state.navBar,\n        ...scenes.rootProps,\n        ...props,\n        key: state.key,\n        from: null,\n      }\n        : {\n          ...state,\n          ...props,\n          key: state.key,\n          from: null,\n        };\n    case ActionConst.PUSH_OR_POP:\n      ind = state.children.findIndex(el => el.sceneKey === action.key);\n      if (ind !== -1) {\n        return {\n          ...state,\n          index: ind,\n          from: state.children[state.index],\n          children: refreshTopChild(state.children.slice(0, ind + 1), action.refresh),\n        };\n      }\n      return {\n        ...state,\n        index: state.index + 1,\n        from: null,\n        children: [...state.children, getInitialState(props, scenes, state.index + 1, action)],\n      };\n    case ActionConst.PUSH:\n      if (state.children[state.index].sceneKey === action.key && !props.clone\n        && checkPropertiesEqual(action, state.children[state.index])) {\n        return state;\n      }\n      return {\n        ...state,\n        index: state.index + 1,\n        from: null,\n        children: [...state.children, getInitialState(props, scenes, state.index + 1, action)],\n      };\n    case ActionConst.JUMP: {\n      assert(state.tabs, `Parent=${state.key} is not tab bar, jump action is not valid`);\n      ind = -1;\n      state.children.forEach((c, i) => { if (c.sceneKey === action.key) { ind = i; } });\n      assert(ind !== -1, `Cannot find route with key=${action.key} for parent=${state.key}`);\n\n      const activeChild = state.children[state.index];\n      const incomingChild = state.children[ind];\n\n      const incomingChildHadTabs = incomingChild.tabs;\n      const incomingChildWasActive = incomingChild.children.length > 1;\n      const activeChildIsIncomingChild = activeChild.sceneKey === action.key;\n      if (incomingChildHadTabs || !incomingChildWasActive || activeChildIsIncomingChild) {\n        state.children[ind] = getInitialState(\n          { ...props },\n          scenes,\n          state.index,\n          { ...action, parentIndex: state.children[ind].parentIndex },\n        );\n      }\n\n      if (action.unmountScenes) {\n        const rState = resetHistoryStack(state);\n        return { ...rState, index: ind };\n      }\n\n      return { ...state, index: ind };\n    }\n    case ActionConst.REPLACE:\n      if (state.children[state.index].sceneKey === action.key) {\n        return state;\n      }\n\n      state.children[state.children.length - 1] = getInitialState(\n        props,\n        scenes,\n        state.index,\n        action,\n      );\n\n      return { ...state, children: state.children };\n    case ActionConst.RESET:\n      if (state.children[state.index].sceneKey === action.key) {\n        return state;\n      }\n\n      state.children = state.children.splice(0, 1);\n      state.children[0] = getInitialState(props, scenes, 0, action);\n\n      return {\n        ...state,\n        index: 0,\n        from: null,\n        children: state.children,\n      };\n    default:\n      return state;\n  }\n}\n\nexport function findElement(state, key, type) {\n  if ((ActionMap[type] === ActionConst.REFRESH && state.key === key) || state.sceneKey === key) {\n    return state;\n  }\n  if (state.children) {\n    for (const child of state.children) {\n      const current = findElement(child, key, type);\n      if (current) return current;\n    }\n  }\n  return null;\n}\n\nexport function getCurrent(state) {\n  if (!state.children) {\n    return state;\n  }\n  return getCurrent(state.children[state.index]);\n}\n\nfunction update(state, action) {\n  // find parent in the state\n  const props = { ...state.scenes[action.key], ...action };\n  assert(props.parent, `No parent is defined for route=${action.key}`);\n  return inject(state, action, props, state.scenes);\n}\n\nfunction reducer({ initialState, scenes }) {\n  assert(initialState, 'initialState should not be null');\n  assert(initialState.key, 'initialState.key should not be null');\n  assert(scenes, 'scenes should not be null');\n  return (stateParam, actionParam) => {\n    let state = stateParam;\n    let action = actionParam;\n    state = state || { ...initialState, scenes };\n    assert(action, 'action should be defined');\n    assert(action.type, 'action type should be defined');\n    assert(state.scenes, 'state.scenes is missed');\n\n    if (action.key) {\n      if (ActionMap[action.type] === ActionConst.REFRESH) {\n        let key = action.key;\n        let child = findElement(state, key, action.type) || state.scenes[key];\n        let sceneKey = child.sceneKey;\n        if (child.base) {\n          child = { ...state.scenes[child.base], ...child };\n          assert(state.scenes[child.base], `No scene exists for base=${child.base}`);\n          key = state.scenes[child.base].key;\n          sceneKey = state.scenes[child.base].sceneKey;\n        }\n        assert(child, `missed child data for key=${key}`);\n        // evaluate functions within actions to allow conditional set, like switch values\n        const evaluated = {};\n        Object.keys(action).forEach((el) => {\n          if (typeof action[el] === 'function' && typeof child[el] !== 'undefined'\n            && typeof child[el] !== typeof action[el]) {\n            evaluated[el] = action[el](child[el], child);\n          }\n        });\n        action = { ...child, ...action, ...evaluated, sceneKey, key };\n\n        // console.log(\"REFRESH ACTION:\", action);\n      } else {\n        const scene = state.scenes[action.key];\n        assert(scene, `missed route data for key=${action.key}`);\n        // clone scene\n        if (scene.clone) {\n          action.parent = getCurrent(state).parent;\n        }\n      }\n    } else {\n      // set current route for pop action or refresh action\n      if (ActionMap[action.type] === ActionConst.BACK_ACTION ||\n        ActionMap[action.type] === ActionConst.BACK ||\n        ActionMap[action.type] === ActionConst.ANDROID_BACK ||\n        ActionMap[action.type] === ActionConst.POP_AND_REPLACE ||\n        ActionMap[action.type] === ActionConst.REFRESH ||\n        ActionMap[action.type] === ActionConst.POP_TO) {\n        if (!action.key && !action.parent) {\n          action = { ...getCurrent(state), ...action };\n        }\n      }\n\n      // Find the parent and index of the future state\n      if (ActionMap[action.type] === ActionConst.POP_TO) {\n        /*\n         * if a string is passed as only argument\n         * Actions.filterParam will put it in the data property\n         * otherwise look for the scene property\n         */\n        const target = action.data || action.scene;\n        assert(target, 'PopTo() must be called with a single argument: ' +\n          'either the scene name (string) or an object with within the scene property ' +\n          'carrying the target scene to pop to');\n\n        const targetEl = findElement(state, target, action.type);\n        assert(targetEl, `Cannot find element name named ${target} within current state`);\n\n        // target is a node\n        let parent = targetEl.sceneKey;\n        let targetIndex = 0;\n\n        // target is child of a node\n        if (!targetEl.children) {\n          const targetParent = findElement(state, targetEl.parent, action.type);\n          assert(targetParent, `Cannot find parent for target ${target}`);\n          parent = targetParent.sceneKey;\n\n          targetIndex = targetParent.children.indexOf(targetEl);\n          assert(targetIndex > -1, `${target} does not belong to ${targetParent.sceneKey}`);\n        }\n\n        action.parent = parent;\n        action.targetIndex = targetIndex;\n      }\n\n      // recursive pop parent\n      if (ActionMap[action.type] === ActionConst.BACK_ACTION ||\n        ActionMap[action.type] === ActionConst.BACK ||\n        ActionMap[action.type] === ActionConst.ANDROID_BACK ||\n        ActionMap[action.type] === ActionConst.POP_AND_REPLACE) {\n        const parent = action.parent || state.scenes[action.key].parent;\n        let el = findElement(state, parent, action.type);\n        while (el.parent && (el.children.length <= 1 || el.tabs)) {\n          el = findElement(state, el.parent, action.type);\n          assert(el, `Cannot find element for parent=${el.parent} within current state`);\n        }\n        action.parent = el.sceneKey;\n      }\n    }\n\n    switch (ActionMap[action.type]) {\n      case ActionConst.BACK:\n      case ActionConst.BACK_ACTION:\n      case ActionConst.POP_AND_REPLACE:\n      case ActionConst.POP_TO:\n      case ActionConst.REFRESH:\n      case ActionConst.PUSH:\n      case ActionConst.PUSH_OR_POP:\n      case ActionConst.JUMP:\n      case ActionConst.REPLACE:\n      case ActionConst.RESET:\n      case ActionConst.ANDROID_BACK:\n        return update(state, action);\n\n      default:\n        return state;\n\n    }\n  };\n}\n\nexport default reducer;\n"]},"metadata":{},"sourceType":"script"}