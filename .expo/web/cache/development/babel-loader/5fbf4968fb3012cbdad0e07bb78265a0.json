{"ast":null,"code":"var _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findElement = findElement;\nexports.getCurrent = getCurrent;\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar ActionConst = _interopRequireWildcard(require(\"./ActionConst\"));\n\nvar _Actions = require(\"./Actions\");\n\nvar _Util = require(\"./Util\");\n\nvar _State = require(\"./State\");\n\nfunction _createForOfIteratorHelperLoose(o) { var i = 0; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } i = o[Symbol.iterator](); return i.next.bind(i); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction checkPropertiesEqual(action, lastAction) {\n  var isEqual = true;\n\n  for (var _i = 0, _Object$keys = Object.keys(action); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n\n    if (['key', 'type', 'parent'].indexOf(key) === -1) {\n      if (action[key] !== lastAction[key]) {\n        isEqual = false;\n      }\n    }\n  }\n\n  return isEqual;\n}\n\nfunction resetHistoryStack(child) {\n  var newChild = child;\n  newChild.index = 0;\n  child.children.map(function (el, i) {\n    if (el.initial) {\n      newChild.index = i;\n\n      if (!newChild.tabs) {\n        newChild.children = [el];\n      }\n    }\n\n    if (el.children) {\n      resetHistoryStack(el);\n    }\n\n    return newChild;\n  });\n}\n\nfunction refreshTopChild(children, refresh) {\n  if (refresh) {\n    var topChild = children[children.length - 1];\n    return [].concat((0, _toConsumableArray2.default)(children.slice(0, -1)), [_objectSpread({}, topChild, {}, refresh)]);\n  }\n\n  return children;\n}\n\nfunction inject(state, action, props, scenes) {\n  var condition = _Actions.ActionMap[action.type] === ActionConst.REFRESH ? state.key === props.key || state.sceneKey === action.key : state.sceneKey === props.parent;\n\n  if (!condition) {\n    if (state.children) {\n      var res = state.children.map(function (el) {\n        return inject(el, action, props, scenes);\n      });\n      var changed = false;\n      var changedIndex = -1;\n\n      for (var i = 0; i < res.length; i += 1) {\n        if (res[i] !== state.children[i]) {\n          changed = true;\n          changedIndex = i;\n          break;\n        }\n      }\n\n      return changed ? _objectSpread({}, state, {\n        children: res,\n        index: changedIndex\n      }) : state;\n    }\n\n    return state;\n  }\n\n  var ind;\n\n  switch (_Actions.ActionMap[action.type]) {\n    case ActionConst.POP_TO:\n      {\n        var targetIndex = action.targetIndex;\n        return _objectSpread({}, state, {\n          index: targetIndex,\n          children: refreshTopChild(state.children.slice(0, targetIndex + 1), action.refresh)\n        });\n      }\n\n    case ActionConst.BACK:\n    case ActionConst.BACK_ACTION:\n      {\n        (0, _Util.assert)(!state.tabs, 'pop() operation cannot be run on tab bar (tabs=true)');\n\n        if (state.index === 0) {\n          return state;\n        }\n\n        var popNum = 1;\n\n        if (action.popNum) {\n          (0, _Util.assert)(typeof action.popNum === 'number', 'The data is the number of scenes you want to pop, it must be Number');\n          popNum = action.popNum;\n          (0, _Util.assert)(popNum % 1 === 0, 'The data is the number of scenes you want to pop, it must be integer.');\n          (0, _Util.assert)(popNum > 1, 'The data is the number of scenes you want to pop, it must be bigger than 1.');\n          (0, _Util.assert)(popNum <= state.index, 'The data is the number of scenes you want to pop, ' + \"it must be smaller than scenes stack's length.\");\n        }\n\n        return _objectSpread({}, state, {\n          index: state.index - popNum,\n          from: state.children[state.children.length - popNum],\n          children: refreshTopChild(state.children.slice(0, -1 * popNum), action.refresh)\n        });\n      }\n\n    case ActionConst.ANDROID_BACK:\n      {\n        if (_reactNative.Platform.OS === 'android') {\n          (0, _Util.assert)(state.index > 0, 'You are already in the root scene.');\n        }\n\n        return _objectSpread({}, state, {\n          index: state.index - 1,\n          from: state.children[state.children.length - 1],\n          children: refreshTopChild(state.children.slice(0, -1), action.refresh)\n        });\n      }\n\n    case ActionConst.POP_AND_REPLACE:\n      {\n        (0, _Util.assert)(!state.tabs, 'pop() operation cannot be run on tab bar (tabs=true)');\n        (0, _Util.assert)(state.index > 0, 'You are already in the root scene.');\n        var _popNum = 1;\n\n        if (action.popNum) {\n          (0, _Util.assert)(typeof action.popNum === 'number', 'The data is the number of scenes you want to pop, it must be Number');\n          _popNum = action.popNum;\n          (0, _Util.assert)(_popNum % 1 === 0, 'The data is the number of scenes you want to pop, it must be integer.');\n          (0, _Util.assert)(_popNum > 1, 'The data is the number of scenes you want to pop, it must be bigger than 1.');\n          (0, _Util.assert)(_popNum <= state.index, 'The data is the number of scenes you want to pop, ' + \"it must be smaller than scenes stack's length.\");\n        }\n\n        state = _objectSpread({}, state, {\n          index: state.index - _popNum,\n          from: state.children[state.children.length - _popNum],\n          children: state.children.slice(0, -1 * _popNum)\n        });\n\n        if (state.children[state.index].sceneKey === action.key) {\n          return state;\n        }\n\n        var newAction = _objectSpread({\n          duration: 0\n        }, action);\n\n        delete newAction.popNum;\n\n        var newProps = _objectSpread({}, props);\n\n        delete newProps.popNum;\n        state.children[state.children.length - 1] = (0, _State.getInitialState)(newProps, scenes, state.index, newAction);\n        return _objectSpread({}, state, {\n          children: state.children\n        });\n      }\n\n    case ActionConst.REFRESH:\n      return props.base ? _objectSpread({\n        navBar: state.navBar\n      }, scenes.rootProps, {}, props, {\n        key: state.key,\n        from: null\n      }) : _objectSpread({}, state, {}, props, {\n        key: state.key,\n        from: null\n      });\n\n    case ActionConst.PUSH_OR_POP:\n      ind = state.children.findIndex(function (el) {\n        return el.sceneKey === action.key;\n      });\n\n      if (ind !== -1) {\n        return _objectSpread({}, state, {\n          index: ind,\n          from: state.children[state.index],\n          children: refreshTopChild(state.children.slice(0, ind + 1), action.refresh)\n        });\n      }\n\n      return _objectSpread({}, state, {\n        index: state.index + 1,\n        from: null,\n        children: [].concat((0, _toConsumableArray2.default)(state.children), [(0, _State.getInitialState)(props, scenes, state.index + 1, action)])\n      });\n\n    case ActionConst.PUSH:\n      if (state.children[state.index].sceneKey === action.key && !props.clone && checkPropertiesEqual(action, state.children[state.index])) {\n        return state;\n      }\n\n      return _objectSpread({}, state, {\n        index: state.index + 1,\n        from: null,\n        children: [].concat((0, _toConsumableArray2.default)(state.children), [(0, _State.getInitialState)(props, scenes, state.index + 1, action)])\n      });\n\n    case ActionConst.JUMP:\n      {\n        (0, _Util.assert)(state.tabs, \"Parent=\" + state.key + \" is not tab bar, jump action is not valid\");\n        ind = -1;\n        state.children.forEach(function (c, i) {\n          if (c.sceneKey === action.key) {\n            ind = i;\n          }\n        });\n        (0, _Util.assert)(ind !== -1, \"Cannot find route with key=\" + action.key + \" for parent=\" + state.key);\n\n        if (action.unmountScenes) {\n          resetHistoryStack(state.children[ind]);\n        }\n\n        state.children[ind] = (0, _State.getInitialState)(props, scenes, state.index, action);\n        return _objectSpread({}, state, {\n          index: ind\n        });\n      }\n\n    case ActionConst.REPLACE:\n      if (state.children[state.index].sceneKey === action.key) {\n        return state;\n      }\n\n      state.children[state.children.length - 1] = (0, _State.getInitialState)(props, scenes, state.index, action);\n      return _objectSpread({}, state, {\n        children: state.children\n      });\n\n    case ActionConst.RESET:\n      if (state.children[state.index].sceneKey === action.key) {\n        return state;\n      }\n\n      state.children = state.children.splice(0, 1);\n      state.children[0] = (0, _State.getInitialState)(props, scenes, state.index, action);\n      return _objectSpread({}, state, {\n        index: 0,\n        from: null,\n        children: state.children\n      });\n\n    default:\n      return state;\n  }\n}\n\nfunction findElement(state, key, type) {\n  if (_Actions.ActionMap[type] === ActionConst.REFRESH && state.key === key || state.sceneKey === key) {\n    return state;\n  }\n\n  if (state.children) {\n    for (var _iterator = _createForOfIteratorHelperLoose(state.children), _step; !(_step = _iterator()).done;) {\n      var child = _step.value;\n      var current = findElement(child, key, type);\n      if (current) return current;\n    }\n  }\n\n  return null;\n}\n\nfunction getCurrent(state) {\n  if (!state.children) {\n    return state;\n  }\n\n  return getCurrent(state.children[state.index]);\n}\n\nfunction update(state, action) {\n  var props = _objectSpread({}, state.scenes[action.key], {}, action);\n\n  (0, _Util.assert)(props.parent, \"No parent is defined for route=\" + action.key);\n  return inject(state, action, props, state.scenes);\n}\n\nfunction reducer(_ref) {\n  var initialState = _ref.initialState,\n      scenes = _ref.scenes;\n  (0, _Util.assert)(initialState, 'initialState should not be null');\n  (0, _Util.assert)(initialState.key, 'initialState.key should not be null');\n  (0, _Util.assert)(scenes, 'scenes should not be null');\n  return function (stateParam, actionParam) {\n    var state = stateParam;\n    var action = actionParam;\n    state = state || _objectSpread({}, initialState, {\n      scenes: scenes\n    });\n    (0, _Util.assert)(action, 'action should be defined');\n    (0, _Util.assert)(action.type, 'action type should be defined');\n    (0, _Util.assert)(state.scenes, 'state.scenes is missed');\n\n    if (action.key) {\n      if (_Actions.ActionMap[action.type] === ActionConst.REFRESH) {\n        var key = action.key;\n        var child = findElement(state, key, action.type) || state.scenes[key];\n        var sceneKey = child.sceneKey;\n\n        if (child.base) {\n          child = _objectSpread({}, state.scenes[child.base], {}, child);\n          (0, _Util.assert)(state.scenes[child.base], \"No scene exists for base=\" + child.base);\n          key = state.scenes[child.base].key;\n          sceneKey = state.scenes[child.base].sceneKey;\n        }\n\n        (0, _Util.assert)(child, \"missed child data for key=\" + key);\n        var evaluated = {};\n        Object.keys(action).forEach(function (el) {\n          if (typeof action[el] === 'function' && typeof child[el] !== 'undefined' && typeof child[el] !== typeof action[el]) {\n            evaluated[el] = action[el](child[el], child);\n          }\n        });\n        action = _objectSpread({}, child, {}, action, {}, evaluated, {\n          sceneKey: sceneKey,\n          key: key\n        });\n      } else {\n        var scene = state.scenes[action.key];\n        (0, _Util.assert)(scene, \"missed route data for key=\" + action.key);\n\n        if (scene.clone) {\n          action.parent = getCurrent(state).parent;\n        }\n      }\n    } else {\n      if (_Actions.ActionMap[action.type] === ActionConst.BACK_ACTION || _Actions.ActionMap[action.type] === ActionConst.BACK || _Actions.ActionMap[action.type] === ActionConst.ANDROID_BACK || _Actions.ActionMap[action.type] === ActionConst.POP_AND_REPLACE || _Actions.ActionMap[action.type] === ActionConst.REFRESH || _Actions.ActionMap[action.type] === ActionConst.POP_TO) {\n        if (!action.key && !action.parent) {\n          action = _objectSpread({}, getCurrent(state), {}, action);\n        }\n      }\n\n      if (_Actions.ActionMap[action.type] === ActionConst.POP_TO) {\n        var target = action.data || action.scene;\n        (0, _Util.assert)(target, 'PopTo() must be called with a single argument: ' + 'either the scene name (string) or an object with within the scene property ' + 'carrying the target scene to pop to');\n        var targetEl = findElement(state, target, action.type);\n        (0, _Util.assert)(targetEl, \"Cannot find element name named \" + target + \" within current state\");\n        var parent = targetEl.sceneKey;\n        var targetIndex = 0;\n\n        if (!targetEl.children) {\n          var targetParent = findElement(state, targetEl.parent, action.type);\n          (0, _Util.assert)(targetParent, \"Cannot find parent for target \" + target);\n          parent = targetParent.sceneKey;\n          targetIndex = targetParent.children.indexOf(targetEl);\n          (0, _Util.assert)(targetIndex > -1, target + \" does not belong to \" + targetParent.sceneKey);\n        }\n\n        action.parent = parent;\n        action.targetIndex = targetIndex;\n      }\n\n      if (_Actions.ActionMap[action.type] === ActionConst.BACK_ACTION || _Actions.ActionMap[action.type] === ActionConst.BACK || _Actions.ActionMap[action.type] === ActionConst.ANDROID_BACK || _Actions.ActionMap[action.type] === ActionConst.POP_AND_REPLACE) {\n        var _parent = action.parent || state.scenes[action.key].parent;\n\n        var el = findElement(state, _parent, action.type);\n\n        while (el.parent && (el.children.length <= 1 || el.tabs)) {\n          el = findElement(state, el.parent, action.type);\n          (0, _Util.assert)(el, \"Cannot find element for parent=\" + el.parent + \" within current state\");\n        }\n\n        action.parent = el.sceneKey;\n      }\n    }\n\n    switch (_Actions.ActionMap[action.type]) {\n      case ActionConst.BACK:\n      case ActionConst.BACK_ACTION:\n      case ActionConst.POP_AND_REPLACE:\n      case ActionConst.POP_TO:\n      case ActionConst.REFRESH:\n      case ActionConst.PUSH:\n      case ActionConst.PUSH_OR_POP:\n      case ActionConst.JUMP:\n      case ActionConst.REPLACE:\n      case ActionConst.RESET:\n      case ActionConst.ANDROID_BACK:\n        return update(state, action);\n\n      default:\n        return state;\n    }\n  };\n}\n\nvar _default = reducer;\nexports.default = _default;","map":{"version":3,"sources":["/Users/apple/Documents/janitri/sampleapp/node_modules/react-native-router-flux/src/Reducer.js"],"names":["checkPropertiesEqual","action","lastAction","isEqual","Object","keys","key","indexOf","resetHistoryStack","child","newChild","index","children","map","el","i","initial","tabs","refreshTopChild","refresh","topChild","length","slice","inject","state","props","scenes","condition","ActionMap","type","ActionConst","REFRESH","sceneKey","parent","res","changed","changedIndex","ind","POP_TO","targetIndex","BACK","BACK_ACTION","popNum","from","ANDROID_BACK","Platform","OS","POP_AND_REPLACE","newAction","duration","newProps","base","navBar","rootProps","PUSH_OR_POP","findIndex","PUSH","clone","JUMP","forEach","c","unmountScenes","REPLACE","RESET","splice","findElement","current","getCurrent","update","reducer","initialState","stateParam","actionParam","evaluated","scene","target","data","targetEl","targetParent"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Pavel Aksonov\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/* eslint-disable no-param-reassign */\n\nimport { Platform } from 'react-native';\nimport * as ActionConst from './ActionConst';\nimport { ActionMap } from './Actions';\nimport { assert } from './Util';\nimport { getInitialState } from './State';\n\n// WARN: it is not working correct. rewrite it.\nfunction checkPropertiesEqual(action, lastAction) {\n  let isEqual = true;\n  for (const key of Object.keys(action)) {\n    if (['key', 'type', 'parent'].indexOf(key) === -1) {\n      if (action[key] !== lastAction[key]) {\n        isEqual = false;\n      }\n    }\n  }\n  return isEqual;\n}\n\nfunction resetHistoryStack(child) {\n  const newChild = child;\n  newChild.index = 0;\n  child.children.map(\n    (el, i) => {\n      if (el.initial) {\n        newChild.index = i;\n        if (!newChild.tabs) {\n          newChild.children = [el];\n        }\n      }\n      if (el.children) {\n        resetHistoryStack(el);\n      }\n      return newChild;\n    },\n  );\n}\n\nfunction refreshTopChild(children, refresh) {\n  if (refresh) {\n    const topChild = children[children.length - 1];\n    return [...children.slice(0, -1), { ...topChild, ...refresh }];\n  }\n  return children;\n}\n\nfunction inject(state, action, props, scenes) {\n  const condition = ActionMap[action.type] === ActionConst.REFRESH ? state.key === props.key ||\n  state.sceneKey === action.key : state.sceneKey === props.parent;\n  // console.log(\"INJECT:\", action.key, state.sceneKey, condition);\n  if (!condition) {\n    if (state.children) {\n      const res = state.children.map(el => inject(el, action, props, scenes));\n      let changed = false;\n      let changedIndex = -1;\n      for (let i = 0; i < res.length; i += 1) {\n        if (res[i] !== state.children[i]) {\n          changed = true;\n          changedIndex = i;\n          break;\n        }\n      }\n      return changed ? { ...state, children: res, index: changedIndex } : state;\n    }\n    return state;\n  }\n  let ind;\n\n  switch (ActionMap[action.type]) {\n    case ActionConst.POP_TO: {\n      const targetIndex = action.targetIndex;\n\n      return {\n        ...state,\n        index: targetIndex,\n        children: refreshTopChild(state.children.slice(0, (targetIndex + 1)), action.refresh),\n      };\n    }\n\n    case ActionConst.BACK:\n    case ActionConst.BACK_ACTION: {\n      assert(!state.tabs, 'pop() operation cannot be run on tab bar (tabs=true)');\n\n      if (state.index === 0) {\n        return state;\n      }\n\n      let popNum = 1;\n      if (action.popNum) {\n        assert(typeof (action.popNum) === 'number',\n          'The data is the number of scenes you want to pop, it must be Number');\n        popNum = action.popNum;\n        assert(popNum % 1 === 0,\n          'The data is the number of scenes you want to pop, it must be integer.');\n        assert(popNum > 1,\n          'The data is the number of scenes you want to pop, it must be bigger than 1.');\n        assert(popNum <= state.index,\n          'The data is the number of scenes you want to pop, ' +\n          \"it must be smaller than scenes stack's length.\");\n      }\n\n      return {\n        ...state,\n        index: state.index - popNum,\n        from: state.children[state.children.length - popNum],\n        children: refreshTopChild(state.children.slice(0, -1 * popNum), action.refresh),\n      };\n    }\n    case ActionConst.ANDROID_BACK: {\n      if (Platform.OS === 'android') {\n        assert(state.index > 0, 'You are already in the root scene.');\n      }\n\n      return {\n        ...state,\n        index: state.index - 1,\n        from: state.children[state.children.length - 1],\n        children: refreshTopChild(state.children.slice(0, -1), action.refresh),\n      };\n    }\n    // This action will pop the scene stack and then replace current scene in one go\n    case ActionConst.POP_AND_REPLACE: {\n      assert(!state.tabs, 'pop() operation cannot be run on tab bar (tabs=true)');\n      assert(state.index > 0, 'You are already in the root scene.');\n\n      let popNum = 1;\n      if (action.popNum) {\n        assert(typeof (action.popNum) === 'number',\n          'The data is the number of scenes you want to pop, it must be Number');\n        popNum = action.popNum;\n        assert(popNum % 1 === 0,\n          'The data is the number of scenes you want to pop, it must be integer.');\n        assert(popNum > 1,\n          'The data is the number of scenes you want to pop, it must be bigger than 1.');\n        assert(popNum <= state.index,\n          'The data is the number of scenes you want to pop, ' +\n          \"it must be smaller than scenes stack's length.\");\n      }\n\n      state = {\n        ...state,\n        index: state.index - popNum,\n        from: state.children[state.children.length - popNum],\n        children: state.children.slice(0, -1 * popNum),\n      };\n\n      if (state.children[state.index].sceneKey === action.key) {\n        return state;\n      }\n\n      const newAction = {\n        duration: 0,  // do not animate\n        ...action,\n      };\n      delete newAction.popNum;\n\n      const newProps = { ...props };\n      delete newProps.popNum;\n\n      state.children[state.children.length - 1] = getInitialState(\n        newProps,\n        scenes,\n        state.index,\n        newAction,\n      );\n\n      return { ...state, children: state.children };\n    }\n    case ActionConst.REFRESH:\n      return props.base ? {\n        navBar: state.navBar,\n        ...scenes.rootProps,\n        ...props,\n        key: state.key,\n        from: null }\n      : {\n        ...state,\n        ...props,\n        key: state.key,\n        from: null,\n      };\n    case ActionConst.PUSH_OR_POP:\n      ind = state.children.findIndex(el => el.sceneKey === action.key);\n      if (ind !== -1) {\n        return {\n          ...state,\n          index: ind,\n          from: state.children[state.index],\n          children: refreshTopChild(state.children.slice(0, ind + 1), action.refresh),\n        };\n      }\n      return {\n        ...state,\n        index: state.index + 1,\n        from: null,\n        children: [...state.children, getInitialState(props, scenes, state.index + 1, action)],\n      };\n    case ActionConst.PUSH:\n      if (state.children[state.index].sceneKey === action.key && !props.clone\n        && checkPropertiesEqual(action, state.children[state.index])) {\n        return state;\n      }\n      return {\n        ...state,\n        index: state.index + 1,\n        from: null,\n        children: [...state.children, getInitialState(props, scenes, state.index + 1, action)],\n      };\n    case ActionConst.JUMP: {\n      assert(state.tabs, `Parent=${state.key} is not tab bar, jump action is not valid`);\n      ind = -1;\n      state.children.forEach((c, i) => { if (c.sceneKey === action.key) { ind = i; } });\n      assert(ind !== -1, `Cannot find route with key=${action.key} for parent=${state.key}`);\n\n      if (action.unmountScenes) {\n        resetHistoryStack(state.children[ind]);\n      }\n\n      state.children[ind] = getInitialState(\n        props,\n        scenes,\n        state.index,\n        action,\n      );\n\n      return { ...state, index: ind };\n    }\n    case ActionConst.REPLACE:\n      if (state.children[state.index].sceneKey === action.key) {\n        return state;\n      }\n\n      state.children[state.children.length - 1] = getInitialState(\n        props,\n        scenes,\n        state.index,\n        action,\n      );\n\n      return { ...state, children: state.children };\n    case ActionConst.RESET:\n      if (state.children[state.index].sceneKey === action.key) {\n        return state;\n      }\n\n      state.children = state.children.splice(0, 1);\n      state.children[0] = getInitialState(props, scenes, state.index, action);\n\n      return {\n        ...state,\n        index: 0,\n        from: null,\n        children: state.children,\n      };\n    default:\n      return state;\n  }\n}\n\nexport function findElement(state, key, type) {\n  if ((ActionMap[type] === ActionConst.REFRESH && state.key === key) || state.sceneKey === key) {\n    return state;\n  }\n  if (state.children) {\n    for (const child of state.children) {\n      const current = findElement(child, key, type);\n      if (current) return current;\n    }\n  }\n  return null;\n}\n\nexport function getCurrent(state) {\n  if (!state.children) {\n    return state;\n  }\n  return getCurrent(state.children[state.index]);\n}\n\nfunction update(state, action) {\n  // find parent in the state\n  const props = { ...state.scenes[action.key], ...action };\n  assert(props.parent, `No parent is defined for route=${action.key}`);\n  return inject(state, action, props, state.scenes);\n}\n\nfunction reducer({ initialState, scenes }) {\n  assert(initialState, 'initialState should not be null');\n  assert(initialState.key, 'initialState.key should not be null');\n  assert(scenes, 'scenes should not be null');\n  return (stateParam, actionParam) => {\n    let state = stateParam;\n    let action = actionParam;\n    state = state || { ...initialState, scenes };\n    assert(action, 'action should be defined');\n    assert(action.type, 'action type should be defined');\n    assert(state.scenes, 'state.scenes is missed');\n\n    if (action.key) {\n      if (ActionMap[action.type] === ActionConst.REFRESH) {\n        let key = action.key;\n        let child = findElement(state, key, action.type) || state.scenes[key];\n        let sceneKey = child.sceneKey;\n        if (child.base) {\n          child = { ...state.scenes[child.base], ...child };\n          assert(state.scenes[child.base], `No scene exists for base=${child.base}`);\n          key = state.scenes[child.base].key;\n          sceneKey = state.scenes[child.base].sceneKey;\n        }\n        assert(child, `missed child data for key=${key}`);\n        // evaluate functions within actions to allow conditional set, like switch values\n        const evaluated = {};\n        Object.keys(action).forEach((el) => {\n          if (typeof action[el] === 'function' && typeof child[el] !== 'undefined'\n            && typeof child[el] !== typeof action[el]) {\n            evaluated[el] = action[el](child[el], child);\n          }\n        });\n        action = { ...child, ...action, ...evaluated, sceneKey, key };\n\n        // console.log(\"REFRESH ACTION:\", action);\n      } else {\n        const scene = state.scenes[action.key];\n        assert(scene, `missed route data for key=${action.key}`);\n        // clone scene\n        if (scene.clone) {\n          action.parent = getCurrent(state).parent;\n        }\n      }\n    } else {\n      // set current route for pop action or refresh action\n      if (ActionMap[action.type] === ActionConst.BACK_ACTION ||\n          ActionMap[action.type] === ActionConst.BACK ||\n          ActionMap[action.type] === ActionConst.ANDROID_BACK ||\n          ActionMap[action.type] === ActionConst.POP_AND_REPLACE ||\n          ActionMap[action.type] === ActionConst.REFRESH ||\n          ActionMap[action.type] === ActionConst.POP_TO) {\n        if (!action.key && !action.parent) {\n          action = { ...getCurrent(state), ...action };\n        }\n      }\n\n      // Find the parent and index of the future state\n      if (ActionMap[action.type] === ActionConst.POP_TO) {\n        /*\n         * if a string is passed as only argument\n         * Actions.filterParam will put it in the data property\n         * otherwise look for the scene property\n         */\n        const target = action.data || action.scene;\n        assert(target, 'PopTo() must be called with a single argument: ' +\n        'either the scene name (string) or an object with within the scene property ' +\n        'carrying the target scene to pop to');\n\n        const targetEl = findElement(state, target, action.type);\n        assert(targetEl, `Cannot find element name named ${target} within current state`);\n\n        // target is a node\n        let parent = targetEl.sceneKey;\n        let targetIndex = 0;\n\n        // target is child of a node\n        if (!targetEl.children) {\n          const targetParent = findElement(state, targetEl.parent, action.type);\n          assert(targetParent, `Cannot find parent for target ${target}`);\n          parent = targetParent.sceneKey;\n\n          targetIndex = targetParent.children.indexOf(targetEl);\n          assert(targetIndex > -1, `${target} does not belong to ${targetParent.sceneKey}`);\n        }\n\n        action.parent = parent;\n        action.targetIndex = targetIndex;\n      }\n\n      // recursive pop parent\n      if (ActionMap[action.type] === ActionConst.BACK_ACTION ||\n          ActionMap[action.type] === ActionConst.BACK ||\n          ActionMap[action.type] === ActionConst.ANDROID_BACK ||\n          ActionMap[action.type] === ActionConst.POP_AND_REPLACE) {\n        const parent = action.parent || state.scenes[action.key].parent;\n        let el = findElement(state, parent, action.type);\n        while (el.parent && (el.children.length <= 1 || el.tabs)) {\n          el = findElement(state, el.parent, action.type);\n          assert(el, `Cannot find element for parent=${el.parent} within current state`);\n        }\n        action.parent = el.sceneKey;\n      }\n    }\n\n    switch (ActionMap[action.type]) {\n      case ActionConst.BACK:\n      case ActionConst.BACK_ACTION:\n      case ActionConst.POP_AND_REPLACE:\n      case ActionConst.POP_TO:\n      case ActionConst.REFRESH:\n      case ActionConst.PUSH:\n      case ActionConst.PUSH_OR_POP:\n      case ActionConst.JUMP:\n      case ActionConst.REPLACE:\n      case ActionConst.RESET:\n      case ActionConst.ANDROID_BACK:\n        return update(state, action);\n\n      default:\n        return state;\n\n    }\n  };\n}\n\nexport default reducer;\n"]},"metadata":{},"sourceType":"script"}