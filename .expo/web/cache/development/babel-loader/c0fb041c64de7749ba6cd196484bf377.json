{"ast":null,"code":"var _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getInitialState = getInitialState;\nexports.default = _default;\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _Util = require(\"./Util\");\n\nvar ActionConst = _interopRequireWildcard(require(\"./ActionConst\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction getStateFromScenes(route, scenes, props) {\n  var getters = [];\n  var result = {};\n  var scene = route;\n\n  while (scene) {\n    if (scene.getInitialState) {\n      getters.push(scene.getInitialState);\n    }\n\n    scene = scenes[scene.parent];\n  }\n\n  if (scenes.rootProps && scenes.rootProps.getInitialState) {\n    getters.push(scenes.rootProps.getInitialState);\n  }\n\n  getters.reverse().forEach(function (fn) {\n    result = _objectSpread({}, result, {}, fn(props));\n  });\n  return result;\n}\n\nfunction getSceneKey(parent, key, position, sceneKey) {\n  return [parent, key, position, sceneKey].filter(function (v) {\n    return typeof v !== 'undefined' && v !== null;\n  }).join('_');\n}\n\nfunction getInitialState(route, scenes) {\n  var position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var props = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var parent = props.parent,\n      key = props.key,\n      style = props.style,\n      type = props.type,\n      parentProps = (0, _objectWithoutProperties2.default)(props, [\"parent\", \"key\", \"style\", \"type\"]);\n\n  if (!route.children) {\n    return _objectSpread({}, scenes.rootProps, {}, route, {\n      key: getSceneKey(parent, key, position, route.sceneKey)\n    }, parentProps, {}, getStateFromScenes(route, scenes, props));\n  }\n\n  var res = _objectSpread({}, route, {}, scenes.rootProps, {}, parentProps);\n\n  var index = 0;\n  route.children.forEach(function (r, i) {\n    (0, _Util.assert)(scenes[r], \"Empty scene for key=\" + route.key);\n\n    if (scenes[r].initial) {\n      index = i;\n    }\n  });\n\n  if (route.tabs) {\n    res.children = route.children.map(function (r, i) {\n      return getInitialState(scenes[r], scenes, i, _objectSpread({}, props, {\n        parentIndex: position\n      }));\n    });\n    res.index = index;\n  } else {\n    res.children = [getInitialState(scenes[route.children[index]], scenes, 0, props)];\n    res.index = 0;\n  }\n\n  if (route.type === ActionConst.JUMP) {\n    res.children = res.children.map(function (child) {\n      return _objectSpread({}, props, {}, child);\n    });\n  }\n\n  res.key = position + \"_\" + res.key;\n  return res;\n}\n\nfunction _default(scenes) {\n  var rootRoute = Object.keys(scenes).find(function (route) {\n    return {}.hasOwnProperty.call(scenes, route) && !scenes[route].parent;\n  });\n  return getInitialState(scenes[rootRoute], scenes);\n}","map":{"version":3,"sources":["/Users/apple/Documents/janitri/sampleapp/node_modules/react-native-router-flux/src/State.js"],"names":["getStateFromScenes","route","scenes","props","getters","result","scene","getInitialState","push","parent","rootProps","reverse","forEach","fn","getSceneKey","key","position","sceneKey","filter","v","join","style","type","parentProps","children","res","index","r","i","initial","tabs","map","parentIndex","ActionConst","JUMP","child","rootRoute","Object","keys","find","hasOwnProperty","call"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Pavel Aksonov\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { assert } from './Util';\nimport * as ActionConst from './ActionConst';\n\nfunction getStateFromScenes(route, scenes, props) {\n  const getters = [];\n  let result = {};\n  let scene = route;\n  while (scene) {\n    if (scene.getInitialState) {\n      getters.push(scene.getInitialState);\n    }\n    scene = scenes[scene.parent];\n  }\n\n  if (scenes.rootProps && scenes.rootProps.getInitialState) {\n    getters.push(scenes.rootProps.getInitialState);\n  }\n\n  getters.reverse().forEach((fn) => {\n    result = { ...result, ...fn(props) };\n  });\n\n  return result;\n}\n\nfunction getSceneKey(parent, key, position, sceneKey) {\n  return [parent, key, position, sceneKey]\n    .filter(v => typeof (v) !== 'undefined' && v !== null)\n    .join('_');\n}\n\nexport function getInitialState(\n  route: {string: any},\n  scenes: {string: any},\n  position = 0,\n  props = {},\n) {\n  // eslint-disable-next-line no-unused-vars\n  const { parent, key, style, type, ...parentProps } = props;\n  if (!route.children) {\n    return {\n      ...scenes.rootProps,\n      ...route,\n      key: getSceneKey(parent, key, position, route.sceneKey),\n      ...parentProps,\n      ...getStateFromScenes(route, scenes, props),\n    };\n  }\n  const res = { ...route, ...scenes.rootProps, ...parentProps };\n  let index = 0;\n  route.children.forEach((r, i) => {\n    assert(scenes[r], `Empty scene for key=${route.key}`);\n    if (scenes[r].initial) {\n      index = i;\n    }\n  });\n\n  if (route.tabs) {\n    res.children = route.children.map(\n      (r, i) => getInitialState(scenes[r], scenes, i, { ...props, parentIndex: position }));\n    res.index = index;\n  } else {\n    res.children = [getInitialState(scenes[route.children[index]], scenes, 0, props)];\n    res.index = 0;\n  }\n\n  // Copy props to the children of tab routes\n  if (route.type === ActionConst.JUMP) {\n    res.children = res.children.map(child => ({ ...props, ...child }));\n  }\n\n  res.key = `${position}_${res.key}`;\n  return res;\n}\n\nexport default function (scenes:{string: any}) {\n  // find \"root\" component and get state from it\n  const rootRoute = Object.keys(scenes).find(route =>\n    ({}).hasOwnProperty.call(scenes, route) && !scenes[route].parent);\n\n  return getInitialState(scenes[rootRoute], scenes);\n}\n"]},"metadata":{},"sourceType":"script"}